# Figures

```{r plot-setup-and-libraries, include = FALSE}
my.col <- c("dodgerblue","brown","orange")
palette(my.col)
library(data.table)
library(ggplot2)
library(ggrepel)
library(cmapR)
library(pheatmap)
library(dplyr, warn=F)
```

## Scoring accuracy
![**Schematic illustrating accuracy components of scoring function**. The accuracy component is computed as the product of gene-wise Spearman correlations with ground truth and the area under the curve AUC of extreme modulations.](figures/deconvolution_contest Fig2_Final_revised.png)

## Accuracy vs. Speed

```{r acc-vs-speed-data, include = FALSE}
speed_acc <- fread("data/holdout_score_time.txt", na.strings="n/a")
soln_desc <- fread("data/solution_descriptions.txt", na.strings="n/a")
speed_acc <- merge(speed_acc, soln_desc, by="handle")
```

```{r, echo=FALSE}
# compute composite accuracy
# in contest, aggregate score was computed as:
# SCORE = MAX_SCORE * (MAX(CORp, 0))2 * AUCp2 * exp(- Tsolution / (3 * Tbenchmark) )
# speed_acc[, acc := cor^2 * auc^2]
```

```{r speed_acc, include=FALSE}
# plot
# let's just show one plate for now
# levs <- c("DTR", "GMM", "k-means", "CNN", "other")
# speed_acc$method_short <- factor(speed_acc$method_short,
#                                  levels=levs)
# ggplot(speed_acc[grepl("^DPK", plate)],
#        aes(x=sec, y=acc, label=rank)) +
#   geom_point(aes(color=method_short), size=2) +
#   geom_text_repel() +
#   scale_color_discrete(name="Method class") +
#   xlab("Time (seconds)") +
#   ylab("Accuracy") +
#   theme_classic() +
#   ggtitle("Accuracy vs. Speed")
```


 ## Median difference  

```{r accuracy-fig, fig.cap = cap, echo = FALSE, fig.width = 7, fig.height = 8.5, cache = TRUE}
cap <- "\\label{fig:accuracy-fig}**Accuracy.** \
          Top panels show empirical CDF of the distribution of the genewise spearman correlation ($\\rho$) \
          between the ground-truth gene-expressions (as detected by UNI) and \
          predictions obtained by the competitors and the benchmark through the deconvolution of DUO data, \
          for the subset of the shRNA (**A.**) and compounds experiments (**B.**). \
          The competitors' eCDFs are right-shifted compared to the benchmark, \
          indicating more accurate predictions. \
          Bottom panels show box plots  of the distribution of the genewise difference in spearman correlation \
          of the gene-expression values obtained by the competitors and the benchmark \
          through the deconvolution of DUO data (outliers excluded), \
          for the shRNA experimetns (**C.**) and the compound experiments (**D.**).\
          Results show the median size of the accuracy improvements was modest, \
          ranging between 2 and 3 percentage points."
ds_cor <- parse.gctx("data/UNI_DUO_gene_spearman_correlations_holdout_n20x976.gctx")
plates <- unique(ds_cor@cdesc$plate)
handles <- unique(ds_cor@cdesc$handle)
panel.bottom <- function(x, ...) {
  plot(NA, NA, ann = FALSE, axes = FALSE, xlim = c(0, 1), ylim = c(0, 1))
  ecdf.list <- apply(x, 2, function(x) ecdf(ifelse(x<0,0,x)))
  sapply(ecdf.list[-4], lines, col = gray(.85), pch = "")
  lines(ecdf.list[[4]], col = "brown", pch = "")
  axis(1, at = c(0, 0.5, 1))
  axis(2, at = c(0, 0.5, 1))
  box()
  legend("topleft", lty=1, col = c("brown", gray(.75)), c("benchmark", "competitors"), bty = "n")
  title(...)
}
par(mfrow = c(3, 2), mar = c(4, 4, 2, 1) + 0.1)
# top panel
panel.bottom (ds_cor@mat[, 1:10], main = "A. shRNAs", xlab = expression(rho), ylab = expression(F(rho)))
panel.bottom (ds_cor@mat[, 11:20], main = "B. compounds", xlab = expression(rho)
  , ylab = expression(F(rho)))
# middle panel
par(mar = c(6, 4, 2, 1) + 0.1)
rank.order <- unique(speed_acc[, c("rank", "handle")]) %>% arrange(rank) %>% pull(handle)
k <- c(4, 8, 3, 9, 10, 1, 7, 2, 6, 5)
for (p in plates) {
  ds_sub <- subset.gct(ds_cor, cid = ds_cor@cdesc$plate == p)
  n <- ncol(ds_sub@mat)
  mean.cor <- apply(ds_sub@mat, 2, mean)
  se.cor <- apply(ds_sub@mat, 2, function(x) sqrt(var(x)/length(x)))
  hi.cor <- mean.cor + se.cor
  lo.cor <- mean.cor - se.cor
  hi.cor.long <- mean.cor + 2*se.cor
  lo.cor.long <- mean.cor - 2*se.cor
  k <- match(rank.order, gsub(".*:", "", names(mean.cor)))
  COL <- c("orange")
  plot(NA, NA, xlim = c(1,n), ylim = range(c(1.02*hi.cor.long,0.98*lo.cor.long)), axes = FALSE, ann = FALSE)
#   segments(x0=1:n, y0 = hi.cor[k], y1 = lo.cor[k], lwd = 3, col = COL)
  arrows(x0=1:n, y0 = hi.cor.long[k], y1 = lo.cor.long[k], code = 3, angle = 90, length = 0.05, col = COL)
  points(x = 1:n, y = mean.cor[k], pch = 19, col = COL)
  axis(1, at =1:n, ds_sub@cdesc$handle[k], las=2)
  axis(2, at = range(mean.cor), format(range(mean.cor), digits = 2))
  abline(h = mean.cor[k[10]], lty = 3, col = gray(.75))
  box()
  title(main = ifelse(grepl("DPK", p), "C. shRNAs", "D. compounds")
      , ylab = expression(bar(rho)))
  legend ("topright", col = COL, lty = 1, "95% CI", bty = "n")
}
# bottom panel 
for (p in plates) {
  ds_sub <- subset.gct(ds_cor, cid = ds_cor@cdesc$plate == p)
  best <- apply(ds_sub@mat, 1, which.max)
  best.count <- table(best)
  names(best.count) <- ds_sub@cdesc$handle
  k <- match(rank.order, gsub(".*:", "", names(best.count)))
  b <- barplot(best.count[k], border = NA, las = 2, ylim = c(0, 350), col = rgb(0,0,1, 0.65), yaxt = "n")
  txt <- paste0(format(100*best.count[k]/sum(best.count), digits = 0),"%")
  axis(2, at = c(0, 100, 200, 300))
  text(x = b, y = best.count[k],txt, pos=3)
  box()
  title(main = ifelse(grepl("DPK", p), "E. shRNAs", "F. compounds"), ylab = "# genes")
}

```

```{r best-genes-by-handle, include = FALSE}
ds_cor <- parse.gctx("data/UNI_DUO_gene_spearman_correlations_holdout_n20x976.gctx")
plates <- unique(ds_cor@cdesc$plate)
genes <- ds_cor@rdesc$id
get_best_cor <- function(rid,cid, ds = ds_cor){
  ds_sub <- subset.gct(ds_cor, rid = rid, cid=cid)
  j <- order(ds_sub@mat)
  ds_sub@cdesc$handle[j]
}
m <- array(NA, c(length(genes),2,10))
for (g in 1:length(genes)) {
  m[g,1,] <- get_best_cor(rid = genes[g], cid=ds_cor@cdesc$plate == plates[1])
  m[g,2,] <- get_best_cor(rid = genes[g], cid=ds_cor@cdesc$plate == plates[2])
}
best_genes_by_handle <- m
```

```{r plot-best-genes-by-handle, echo = FALSE, fig.width=7.1,fig.height=4,fig.cap=cap}
cap <- "Distribution of the number of genes swith the highest Spearman rank correlation \
        overall for each algorithm, as computed on the holdout dataset."
x1 <- sort(xtabs(~best_genes_by_handle[,1,10]))#dpk
x2 <- xtabs(~best_genes_by_handle[,2,10])[names(x1)]#litmus
par(mfrow=c(1,2), mar = c(6, 4, 3, 1)+.1)
plot(as.numeric(x1), pch = 1, ann = FALSE, axes = FALSE, ylim = range(c(x1,x2)))
points(as.numeric(x2), pch = 16)
axis(1, at=1:10,names(x1),las=2)
axis(2, at=c(0,100,200,300,400))
box()
legend("topleft", pch = c(1, 16), c("shRNA","compounds"), cex=.75, bty = "n")
title(main = "D. first best predictors", ylab =expression(paste("# genes with highest ",rho)))
# second best
x1 <- sort(xtabs(~best_genes_by_handle[,1,9]))#dpk
x2 <- xtabs(~best_genes_by_handle[,2,9])[names(x1)]#litmus
par(mar = c(6, 4, 3, 1)+.1)
plot(as.numeric(x1), pch = 1, ann = FALSE, axes = FALSE, ylim = range(c(x1,x2)))
points(as.numeric(x2), pch = 16)
axis(1, at=1:10,names(x1),las=2)
axis(2, at=c(50,100,150))
box()
legend("topleft", pch = c(1, 16), c("shRNA","compounds"), cex=.75, bty = "n")
title(main = "E. second best predictors", ylab =expression(paste("# genes with highest ",rho)))
```

# KD accuracy & recall 

```{r kd-comparison, fig.width = 7, fig.cap = cap, echo = FALSE}
cap <- "\\label{fig:kd}**Gene knockdown.** Precision and fraction of gene knockdown recalled by each algorithm. \
          Precision is low because ... "
kd.sorted <- sort(with(speed_acc, tapply(kd_success_freq, handle, mean, na.rm=T)))
kd_precision.sort <- sort(with(speed_acc, tapply(kd_precision, handle, mean, na.rm=T)))
par(mfrow = c(1, 2), mar = c(6, 4, 3, 1)+.1)
plot(kd.sorted, ann = FALSE, axes = FALSE, ylim = c(0.5, 1), pch = 19)
axis(1, at = 1:length(kd.sorted), names(kd.sorted), las = 2)
axis(2, at = c(0, 0.5, 0.75, 1))
box()
title("Recall")
plot(kd_precision.sort, ann = FALSE, axes = FALSE, ylim = c(0, 0.1), pch = 19)
axis(1, at = 1:length(kd_precision.sort), names(kd_precision.sort), las = 2)
axis(2, at = c(0, 0.05, 0.1))
box()
title("Precision*")
```


## Inter-replicate variance 

```{r, include = FALSE}
(ds <- parse.gctx("data/DECONV_holdout_n8228x976.gctx"))
annot <- fread("data/holdout_sample_annotations.txt")
gene_annot <- fread("data/barcode_to_gene_map.txt", colClasses = c("gene_id"="character"))
ds <- annotate.gct(ds, annot, dim="col", keyfield="id")
ds <- annotate.gct(ds, gene_annot, dim="row", keyfield="gene_id")
```

```{r comp-mean-var, include = FALSE, cache = TRUE}
handles <- unique(ds@cdesc$handle)
perts <- unique(ds@cdesc$pert_id)
gene_id <- ds@rdesc$gene_id
n.perts <- length(perts) # 121
n.genes <- length(gene_id) # 976
high <- ds@rdesc$high_prop == 1
n.high <- sum(high) # 488 
library(parallel)
out <- mclapply(handles, function(h) {
  out.var <- out.mean <- array(NA, c(n.genes, n.perts))
  obs <- numeric(length(perts))
  for (j in 1:length(perts)) {
     cids <- which(ds@cdesc$pert_id==perts[j] & ds@cdesc$handle==h)
     mat <- subset.gct(ds, cid=cids, rid=gene_id)@mat
     #cids.gt <- which(ds@cdesc$pert_id==perts[j] & ds@cdesc$handle=="ground-truth")
     #mat.gt <- subset.gct(ds, cid=cids, rid=gene_id)@mat
     out.mean[, j] <-  apply(log(mat), 1, mean)
     out.var[, j] <-  apply(log(mat), 1, var)     
     obs[j] <-  length(cids)    
  }
  list(mean = out.mean, var = out.var, n = obs)
})
names(out) <- handles
```

## Variance by experiments 

```{r var-ratio, fig.width=7, fig.cap=cap, echo = FALSE}
cap <- "\\label{fig:inter-replicate-variance}Inter-replicate variance."
panel <- function(x, margin = 1, ...) {
  y <- apply(x, margin, mean)
  lines(ecdf(y), pch = "", ...)
  axis(1, at = c(0, 0.05, 0.1))
  axis(2, at = c(0, 0.5, 1))
  box()
}

par( mfrow = c(1, 2))
plot(NA, NA, xlim = c(0, .1), ylim = c(0, 1), ann = FALSE, axes = FALSE)
for (j in names(out)){
  panel(out[[j]]$var[high, ], col = gray(.75))
  panel(out[["benchmark"]]$var[high, ], col = "brown", lwd = 2)
#   panel(out[["ground-truth"]]$var[high, ], col = "orange", lwd = 2)
  title(main = "High bead proportion")
}
plot(NA, NA, xlim = c(0, .1), ylim = c(0, 1), ann = FALSE, axes = FALSE)
for (j in names(out)){
  panel(out[[j]]$var[!high, ], col = gray(.75))
  panel(out[["benchmark"]]$var[!high, ], col = "brown", lwd = 2)
#   panel(out[["ground-truth"]]$var[!high, ], col = "orange", lwd = 2)
  title(main = "Low bead proportion")
  legend("bottomright", lty=1, col=c("brown", gray(.75)), c("benchmark", "competitors"), bty = "n")
}
```

```{r setup, include = FALSE}
impute <- function(x, value) ifelse(is.na(x), value, x)
n <- nrow(speed_acc)
attach(speed_acc)
```

# Runtime and speedups 

```{r runtime-speedups, fig.width = 7, fig.cap = cap, echo = FALSE}
cap <- "**Speed improvements.** Distribution of the per-plate runtime (in seconds) and speedups over the benchmark ($t_{\\text{benchmark}}/t_{\\text{competitor}}$) for each of the competitors' algorithms"
sec.mean <- sort(tapply(sec, handle, mean))
handle_f <- factor(handle, levels = names(sort(sec.mean)))
sec.bench <- sec[which(handle == "benchmark")]

par(mfrow = c(1, 2), mar = c(6, 4, 3, 1)+.1)
plot(as.numeric(handle_f), sec
  , pch = c(1, 16)[factor(plate)], xaxt = "n", xlab = "", xlim = c(1, 10.5)
  , ylab = "runtime (seconds)"
  , main = "A. runtime")
axis(1, at = 1:10, levels(handle_f), las=2)
legend("topleft", pch = c(1, 16), c("shRNA","compounds"), cex=.75, bty = "n")
plot(as.numeric(handle_f), sec.bench[factor(plate)]/sec
  , pch = c(1, 16)[factor(plate)]
  , xaxt = "n", xlab = "", xlim = c(1, 10.5)
  , ylab = "speedup"
  , main = "B. speedup")
axis(1, at = 1:10, levels(handle_f), las=2)
legend("topright", pch = c(1, 16), c("shRNA","compounds"), cex=.75, bty = "n")
```

## Accuracy 

```{r, include=FALSE}
par(mar=c(6,2,2,2))
plot(auc[plate==factor(plate)[1]], type="b", ylim=c(0.9,0.96))
axis(1, at=1:10, handle[plate==factor(plate)[1]], las=2)
```

```{r acc-vs-speed, fig.width=8, fig.height=3.5, fig.cap=cap, include = FALSE}
cap <- "\\label{fig:acc-vs-speed}**Accuracy vs speed.** This figure shows the relationship between improvements in AUC (A.), correlation (B.) and fraction of correctly predicted knocked-down genes(C.) and improvements in speed for the top-nine solutions. These measures are computed for each of the plates on the holdout dataset. Labels at the dots indicate the rank of the submission in the final leaderboard (1 = first best, 2 = second best, etc.). Dashed lines indicate levels with no improvement over the benchmark. Dotted lines indicate (ols) association between accuracy and speed improvements. The name of the most accurate and fastest approach are highlighted in each panel."

# compute measures
bench <- handle=="benchmark"
sec.bench <- sec[bench]
auc.bench <- auc[bench]
cor.bench <- cor[bench]
kd.bench <- kd_success_freq[bench]
auc.pc <- auc/auc.bench[factor(plate)]
cor.pc <- cor/cor.bench[factor(plate)]
sec.pc <- sec/sec.bench[factor(plate)]
kd.pc <- kd_success_freq/kd.bench[factor(plate)]
method2 <- method
method2[grep("Gaussian", method)] <- "gaussian mixture"
method2[grep("forest", method)] <- "rand. forest"

# Plot
panel <- function(x,y, xlim=c(0,5), ylim=c(0,0.08), xlab="speed increase (%)", legend=T, ...){
  plot(y ~ x, xlim=xlim, ylim=ylim, xlab=xlab
    , pch=c(15:16)[factor(plate)]
    , col=c(1,2)[factor(plate)]
    , subset=!bench
    ,...)
  # lable best method
  j <- which.max(y)
  y.offset <- +0.002; x.offset <- -1
  segments(y0=y[j], x0=x[j], y1=y[j] + y.offset, x1=x[j]+x.offset)
  text(y=y[j]+y.offset, x=x[j]+x.offset, labels=method2[j], pos=3)
  # label fastest method
  j <- which.max(x)
  y.offset <- -0.001; x.offset <- -0.2
  segments(y0=y[j], x0=x[j], y1=y[j] + y.offset, x1=x[j]+x.offset)
  text(y=y[j]+y.offset, x=x[j]+x.offset, labels=method2[j], pos=1)
  # legend
  if(legend)
    legend("topright", pch=15:16, col=1:2, legend=c("plate 1", "plate 2"), bty="n")
  # rank labels
  text(y=y[!bench],x=x[!bench],labels=rank[!bench],pos=3,xpd=T, col=gray(.75))
  abline(h=0,lty=2)
  abline(v=0,lty=2)
  abline(lm(y[!bench] ~ x[!bench]), lty=3)
}
par(mfrow=c(1,2), mar=c(4,4,2,1)+0.1)
panel(abs(log(sec.pc)),log(auc.pc), ylim=c(0,0.04), ylab="auc increase (%)")
mtext(at=c(0,0), "A.", adj=0, font=2)
panel(abs(log(sec.pc)),log(cor.pc), ylim=c(0,0.07), ylab="corr increase (%)")
mtext(at=c(0,0), "B.", adj=0, font=2)
#panel(abs(log(sec.pc)), log(kd.pc),ylim=c(-0.1,0.1), ylab="kd success (%)")
#mtext(at=c(0,0), "C.", adj=0, font=2)

# Ensambles 20 x 20
# auc.ens <- sapply(auc, function(x) auc + (x - auc*x)*runif(1))
# sec.ens <- sapply(sec, function(x) sec + x)
# plot(auc.ens ~ log(sec.ens), pch=16)
```

## Gene knockdowns

```{r kd_barplot, echo=F, fig.cap=cap, fig.width=6, include = FALSE}
cap <- "\\label{kd_barplot}**KD success frequency.** Bars represent the fraction of landmark-targeting shRNAs experiments in which the DE values indicated successful knockdown (KD). Success criteria are a z-score of less than -2 and a gene-wise rank of less than 10. Results are shown for the one plate of shRNA holdout data, containing 376 landmark-targeting shRNA experiments."

# speed_acc <- fread("data/holdout_score_time.txt", na.strings = "n/a")
# soln_desc <- fread("data/solution_descriptions.txt", na.strings="n/a")
soln_desc <- rbind(soln_desc, data.table(rank="ground-truth",
                                         handle="ground-truth",
                                         method="ground-truth",
                                         method_short="GT"),
                   use.names=T, fill=T)
speed_acc <- merge(speed_acc, soln_desc, by="handle")
levs <- c("DTR", "GMM", "k-means", "CNN", "other", "GT")
speed_acc$method_short <- factor(speed_acc$method_short,
                                 levels=levs)
# make plot
par(mar=c(6, 4, 4, 2) + 0.1, cex=0.9)
with(speed_acc[!is.na(kd_success_freq)][
  order(kd_success_freq, decreasing = F)
], {
  maxval <- max(kd_success_freq)
  offset_factor <- 0.1
  offset <- offset_factor * maxval
  cols <- rep("gray", length(kd_success_freq))
  cols[handle=="benchmark"] <- "red"
  cols[handle=="ground-truth"] <- "black"
  bp <- barplot(kd_success_freq, names.arg=handle, las=3, col=cols,
           ylab="Fraction of successful KD predictions",
           main="Gene Knockdown Success Frequency",
           ylim=c(0, maxval + (2 * offset)))
  text(bp, kd_success_freq + offset, labels=round(kd_success_freq, 2), col="red")
})
```

## High / Low bead discrepancy

```{r hi_lo_bead_input, include=FALSE, echo=F}
# read the GCTX file as a GCT object
# data are stored as a matrix with genes on rows and sample/algo combos on columns
# (ds <- parse.gctx("data/DECONV_holdout_n8228x976.gctx"))
# read annotations and apply to columns
# annot <- fread("data/holdout_sample_annotations.txt")
# gene_annot <- fread("data/barcode_to_gene_map.txt", colClasses = c("gene_id"="character"))
# ds <- annotate.gct(ds, annot, dim="col", keyfield="id")
# ds <- annotate.gct(ds, gene_annot, dim="row", keyfield="gene_id")
```

```{r plot-ecdf, echo=FALSE, fig.width=9,fig.height=9, fig.cap=cap}

# datasets by handles
# handles <- unique(ds@cdesc$handle)
# all_ds <- lapply(handles, function(h) subset.gct(ds, cid=which(ds@cdesc$handle==h)))
# names(all_ds) <- handles
# 
# # benchmark vs ground truth
# gt_ds <- all_ds[["ground-truth"]]
# bench_ds <- all_ds[["benchmark"]]
# 
# # compute stats
# compute.stats <- function(mat) {
#   out <- list()
#   out$gene_level.mean <- apply(mat, 1, mean)
#   out$gene_level.sd <- apply(mat, 1, sd)
#   out$sample_level.mean <- apply(mat, 2, mean)
#   out$sample_level.sd <- apply(mat, 2, sd)
#   return(out)
# }
# all_ds.stats <- lapply(all_ds, function(x) compute.stats(x@mat))
# 
# # Compute stats for Uni and Duo benchmark
# gt_ds.stats <- all_ds.stats[["ground-truth"]] 
# bench_ds.stats <- all_ds.stats[["benchmark"]] 
# 
# # Plot differences
# cap <- paste("Differences in estimates -- ", names(gt_ds.stats))
# for (k in names(gt_ds.stats)) {
#   par(mfrow=c(3,3), mar=c(4,2,2,2)+.1)
#   for(j in setdiff(handles, c("ground-truth","benchmark"))) {
#     ecdf(gt_ds.stats[[k]] %>% log) %>% plot(main=j, xlab=k, pch=".", col=1)
#     ecdf(bench_ds.stats[[k]] %>% log) %>% lines(pch=".", col=2)
#     ecdf(all_ds.stats[[j]][[k]] %>% log) %>% lines(pch=".", col=3)
#     legend("topleft", col=1:3, lty=1, bty="n", c("Uni (no-deconv)", "Duo (k-means)", "Duo (comp.)"))
#   }
# }
```

```{r, echo=F}
# example - plot raw expression values by high vs low bead in ground truth
# row_groups <- with(gt_ds@rdesc, split(1:nrow(gt_ds), high_prop))
# boxplot(list(
#   low_prop = log(gt_ds@mat[row_groups[[1]], ]),
#   high_prop = log(gt_ds@mat[row_groups[[2]], ])
# ), ylab="raw expression")
```


## Clustering of solutions

```{r clus_setup, echo=FALSE}
# read tsne files and other data
tsne_de <- fread("data/holdout_tsne_DE.txt")
tsne_deconv <- fread("data/holdout_tsne_DECONV.txt")
soln_desc <- fread("data/solution_descriptions.txt", na.strings="n/a")

# add a row for ground truth
soln_desc <- rbind(soln_desc, data.table(rank="ground-truth",
                                         handle="ground-truth",
                                         method="ground-truth",
                                         method_short="GT"),
                   use.names=T, fill=T)

# extract handle and plate info
tsne_de[, handle := unlist(strsplit(rid, ":"))[1], .(rid)]
tsne_de[, plate := unlist(strsplit(unlist(strsplit(rid, ":"))[2], "_"))[1], .(rid)]
tsne_de[, pert_type := switch(plate,
                              "DPK.CP003" = "compound",
                              "LITMUS.KD019" = "shRNA"),
        .(rid)]

tsne_deconv[, handle := unlist(strsplit(rid, ":"))[1], .(rid)]
tsne_deconv[, plate := unlist(strsplit(unlist(strsplit(rid, ":"))[2], "_"))[1], .(rid)]
tsne_deconv[, pert_type := switch(plate,
                              "DPK.CP003" = "compound",
                              "LITMUS.KD019" = "shRNA"),
        .(rid)]

# merge with solution desc
tsne_de <- merge(tsne_de, soln_desc, by="handle", all.x=T)
tsne_deconv <- merge(tsne_deconv, soln_desc, by="handle", all.x=T)

# set factor levels
levs <- c("DTR", "GMM", "k-means", "CNN", "other", "GT")
tsne_de$method_short <- factor(tsne_de$method_short,
                               levels=levs)
tsne_deconv$method_short <- factor(tsne_deconv$method_short,
                               levels=levs)
```

```{r tsne_deconv-1, echo=F}
p_deconv_color_type <- ggplot(tsne_deconv, aes(x=TS1, y=TS2, color=pert_type)) +
  geom_point(alpha=0.5, size=1) +
  guides(color=guide_legend(override.aes = list(alpha=1, size=1))) +
  scale_color_discrete(name="") +
  theme_bw() +
  theme(axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank()) +
  ggtitle("DECONV colored by perturbagen type")
```

```{r tsne_deconv-2, echo=F}
p_deconv_color_method <- ggplot(tsne_deconv, aes(x=TS1, y=TS2, color=method_short)) +
  geom_point(alpha=0.5, size=0.5) +
  guides(color=guide_legend(override.aes = list(alpha=1, size=1))) +
  scale_color_discrete(name="") +
  theme_bw() + 
  theme(axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank()) +
  ggtitle("DECONV colored by algorithm type")
```

```{r tsne_deconv-3, echo=F}
p_deconv_facet_handle <- p_deconv_color_method + facet_wrap(~method_short+handle)
```


```{r tsne_de, echo=F}
p_de <- ggplot(tsne_de, aes(x=TS1, y=TS2, color=method_short)) +
  geom_point(alpha=0.5, size=0.5) +
  guides(color=guide_legend(override.aes = list(alpha=1, size=1))) +
  scale_color_discrete(name="") +
  theme_bw() +
  theme(axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank()) +
  facet_wrap(~method_short+handle) +
  ggtitle("DE colored by algorithm type")
```

```{r tsne_figure, fig.height=7, fig.width=12, fig.cap=cap, echo=F, warning=F, cache = TRUE, dependson = "clus_setup"}
cap <- "\\label{tsne_figure}**t-SNE projection of deconvoluted data.** Each point represents the 2D projection of a sample generated by UNI ground truth (GT) or by applying a deconvolution algorithm to DUO data. t-SNE was run on the 2 plates of holdout data, one each containing compound and shRNA treatmens. DECONV data colored by perturbagen type (A) and algorithm type (B). DECONV (C) and DE (D) data colored by algorithm type and stratified by each individual implementation."
cowplot::plot_grid(p_deconv_color_type,
                   p_deconv_color_method,
                   p_deconv_facet_handle,
                   p_de,
                   align="hv", ncol=2, nrow=2, rel_heights = c(1, 1.6),
                   labels=LETTERS[1:4])
```


```{r gene_clus_setup, echo=F}
# corr_ds <- parse.gctx("data/UNI_DUO_gene_spearman_correlations_holdout_n20x976.gctx")
# soln_desc <- fread("data/solution_descriptions.txt", na.strings="n/a")
# corr_ds <- annotate.gct(corr_ds, soln_desc, dim="col", keyfield = "handle")
```

```{r gene_clus, echo=F, fig.cap=cap}
# cap <- "\\label{gene_clus}**Clustering gene-level accuracy.** A clustered matrix of the gene-level correlations between algorithm predictions and UNI ground truth using DECONV data. Columns correspond to genes and rows to algorithms."
# this_ds <- subset.gct(corr_ds, cid=grep("^DPK", corr_ds@cid))
# N <- 100
# m <- t(this_ds@mat)
# rownames(m) <- this_ds@cdesc$handle
# idx <- match(rownames(m), soln_desc$handle)
# annot_df <- data.frame(method=soln_desc$method_short[idx])
# annot_df$method <- factor(annot_df$method,
#                           levels=levs)
# rownames(annot_df) <- rownames(m)
# # rownames(m) <- paste(soln_desc$method_short, rownames(m), sep=":")
# x <- seq(min(m), max(m), length.out=N)
# mypal <- c(
#   colorRampPalette(c("blue", "white"))(sum(x < 0)),
#   colorRampPalette(c("white", "red"))(sum(x >= 0))
# )
# pheatmap(m, color=mypal, scale="none",
#          show_colnames = F,
#          annotation_row=annot_df,
#          annotation_names_row = F)
```

```{r, echo=F}
# TODO: a figure showing the performance difference for the top 2 algos per gene
# genes with a large difference are those that are correctly predicted by only one
# algo, and hence might be the best candidates for improvement by ensemble approaches
# best_cor_per_gene <- apply(m, 2, max)
# best_algo_per_gene <- rownames(m)[apply(m, 2, which.max)]
# diff_to_next_best <- apply(m, 2, function(x) max(x) - max(x[-which.max(x)]))
# diff_to_median <- apply(m, 2, function(x) max(x) - median(x[-which.max(x)]))
# par(pty="s")
# plot(best_cor_per_gene, diff_to_median, col=rgb(0, 0, 0, 0.7),
#      xlab="Max. Correlation", ylab="Delta from Median Correlation")
# text_idx <- which(best_cor_per_gene >= 0.4 & diff_to_median >= 0.15)
# text(best_cor_per_gene[text_idx],
#      diff_to_median[text_idx],
#      labels=best_algo_per_gene[text_idx],
#      adj= -0.1, col="red")
# df <- data.table(handle=best_algo_per_gene,
#                  best_cor=best_cor_per_gene,
#                  med_diff=diff_to_median)
# ggplot(df, aes(x=best_cor, y=med_diff, label=handle)) +
#   geom_point(alpha=0.5) +
#   xlab("Max. correlation") +
#   ylab("Delta from median correlation") +
#   ggtitle("Algorithm-specific gene performance") +
#   geom_text_repel(data=df[best_cor >= 0.4 & med_diff >= 0.15],
#                   color="red")
```


## Complementarity

```{r best_algo_per_gene_bar, echo=F, fig.width=7}
corr_ds <- parse.gctx("data/UNI_DUO_gene_spearman_correlations_holdout_n20x976.gctx")
plates <- unique(corr_ds@cdesc$plate)
par(mar=c(8, 4, 4, 2)+0.1, mfrow=c(1, 2))
for (p in plates) {
  this_ds <- subset.gct(corr_ds, cid=which(corr_ds@cdesc$plate==p &
                                             corr_ds@cdesc$handle != "ground-truth"))
  best_idx <- apply(this_ds@mat, 1, which.max)
  tbl <- table(this_ds@cdesc$handle[best_idx])
  tbl <- sort(tbl, decreasing = F)
  maxval <- max(tbl)
  offset_factor <- 0.1
  offset <- offset_factor * maxval
  cols <- rep("gray", length(tbl))
  cols[names(tbl)=="benchmark"] <- "red"
  bp <- barplot(tbl, las=3, col=cols,
           ylab="Number of genes",
           main=ifelse(grepl("^DPK", p), "compounds", "shRNA"),
           ylim=c(0, maxval + (2 * offset)))
  text(bp, tbl + offset, labels=tbl, col="red")
}
```

TODO: barplot of # of genes for which each algo. gives best prediction
- possible group by plate/low vs. high

## Ensemble
```{r ensemble_setup, echo=F}
# inputs
speed_acc <- fread("data/holdout_score_time.txt", na.strings="n/a")
ens_corr <- fread("data/DPK.CP003_PC3_24H_X1_B42_DECONV_correlation_scores.txt")
ens_auc <- fread("data/DPK.CP003_PC3_24H_X1_B42_DE_auc_scores.txt")
# merge
ens <- merge(ens_corr, ens_auc, by=c("algos", "nalgo"))
# compute total runtime for each algo combo
ens[, sec := {
  these_algos <- unlist(strsplit(algos, ":"))
  sum(speed_acc[handle %in% these_algos]$sec)
}, algos]

# stack
speed_acc$nalgo <- 1
setnames(speed_acc, "handle", "algos")
tmp <- rbind(ens[!grepl("benchmark", algos)], 
             speed_acc[plate=="DPK.CP003_PC3_24H_X1_B42", .(algos, cor, auc, sec, nalgo)],
             fill=T, use.names=T)
```

```{r ensemble_plot_cor, echo=F}
ggplot(tmp, aes(x=sec, y=cor)) +
  geom_point(aes(size=nalgo), alpha=0.6) +
  geom_point(data=tmp[nalgo==1],
             aes(x=sec, y=cor, color=algos)) +
  scale_size_continuous(breaks = seq(1, 9, 2), name="num. algos") +
  scale_color_discrete(name="handle") +
  xlab("cumulative runtime (sec)") +
  ylab("correlation score")
```

```{r ensemble_plot_auc, echo=F}
ggplot(tmp, aes(x=sec, y=auc)) +
  geom_point(aes(size=nalgo), alpha=0.6) +
  geom_point(data=tmp[nalgo==1],
             aes(x=sec, y=auc, color=algos)) +
  scale_size_continuous(breaks = seq(1, 9, 2), name="num. algos") +
  scale_color_discrete(name="handle") +
  xlab("cumulative runtime (sec)") +
  ylab("AUC score")
```

```{r ensemble_plot_pr, echo=F}
ggplot(tmp, aes(x=sec, y=pr)) +
  geom_point(aes(size=nalgo), alpha=0.6) +
  geom_point(data=tmp[nalgo==1],
             aes(x=sec, y=pr, color=algos)) +
  scale_size_continuous(breaks = seq(1, 9, 2), name="num. algos") +
  scale_color_discrete(name="handle") +
  xlab("cumulative runtime (sec)") +
  ylab("Precision-recall AUC")
```


```{r ensemble_plot2_cor, echo=F}
ggplot(tmp, aes(x=nalgo, y=cor, group=nalgo)) +
  geom_boxplot() +
  geom_jitter(width=0.25, alpha=0.6) +
  scale_x_continuous(breaks=1:10) +
  xlab("# of algos combined") +
  ylab("correlation score")
```

```{r ensemble_plot2_auc, echo=F}
ggplot(tmp, aes(x=nalgo, y=auc, group=nalgo)) +
  geom_boxplot() +
  geom_jitter(width=0.25, alpha=0.6) +
  scale_x_continuous(breaks=1:10) +
  xlab("# of algos combined") +
  ylab("AUC score")
```

```{r ensemble_plot2_pr, echo=F}
ggplot(tmp, aes(x=nalgo, y=pr, group=nalgo)) +
  geom_boxplot() +
  geom_jitter(width=0.25, alpha=0.6) +
  scale_x_continuous(breaks=2:10) +
  xlab("# of algos combined") +
  ylab("Precision-recall AUC")
```

```{r, echo=F}
# ggplot(tmp, aes(x=cor, y=auc, size=nalgo)) + 
#   geom_point(alpha=0.6) +
#   scale_size_continuous(breaks = seq(1, 9, 2), name="num. algos")
```


