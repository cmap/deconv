
```{r setup-and-libraries, echo=FALSE, warning=FALSE}
my.col <- c(rgb(1,0,0,0.25), rgb(0,0,1,0.25))
palette(my.col)
library(data.table)
library(ggplot2)
library(ggrepel)
library(cmapR)
library(dplyr, warn=F)
library(parallel)
```

## Load data 

```{r hi_lo_bead_input, include=FALSE}
(ds <- parse.gctx("data/DECONV_holdout_n8228x976.gctx"))
annot <- fread("data/holdout_sample_annotations.txt")
gene_annot <- fread("data/barcode_to_gene_map.txt", colClasses = c("gene_id"="character"))
ds <- annotate.gct(ds, annot, dim="col", keyfield="id")
ds <- annotate.gct(ds, gene_annot, dim="row", keyfield="gene_id")
```

## Methods

We want to see whether algorithms provide similar esimtates under similar conditions. 
The holdout dataset contains measurements from 122 experiments (pert_id) for 976 genes for about 10 replicates. 
We computed the mean and variance ge level for all the different methods (1 UNI method (ground-truth) and 10 DUO method - d-Peak algorithm combinations). We now that the bias is small because correlation with ground truth is also high. 
But we do not know the variance. 

The presence of numerous replicates enables us to compute the MEAN and SD of the gene expression level for all the 976 genes across xxx experiments. This gives us an array with 122 x 976 x 2 values for each of the 11 different methods. 

## Results 

First compute mean and variance for all the data. 

```{r params, include = FALSE}
handles <- unique(ds@cdesc$handle)
perts <- unique(ds@cdesc$pert_id)
gene_id <- ds@rdesc$gene_id
n.perts <- length(perts) # 121
n.genes <- length(gene_id) # 976
high <- ds@rdesc$high_prop == 1
n.high <- sum(high) # 488 
```

```{r comp-mean-var, include = FALSE, cache = TRUE}
library(parallel)
out <- mclapply(handles, function(h) {
  out.var <- out.mean <- array(NA, c(n.genes, n.perts))
  for (j in 1:length(perts)) {
     cids <- which(ds@cdesc$pert_id==perts[j] & ds@cdesc$handle==h)
     mat <- subset.gct(ds, cid=cids, rid=gene_id)@mat
     #cids.gt <- which(ds@cdesc$pert_id==perts[j] & ds@cdesc$handle=="ground-truth")
     #mat.gt <- subset.gct(ds, cid=cids, rid=gene_id)@mat
     out.mean[, j] <-  apply(log(mat), 1, mean)
     out.var[, j] <-  apply(log(mat), 1, var)     
  }
  list(mean=out.mean, var=out.var)
})
names(out) <- handles
```

## Variance by experiments 

```{r var-ratio, fig.width=7.1, fig.height=7,fig.cap=c("a","b")}
panel <- function(x, type = "experiments", prob = c(0.55,0.5, 0.45), ...) {
  margin <- switch(type, genes = 1, experiments = 2)
  y <- apply(x, margin, quantile, p = prob)
  matplot(t(y), type="l"
          , ylab = "variance ratio"
          , ...)
}
par(mfrow=c(4, 3),mar=c(4,4,2,2))
for (j in names(out)){
  k <- order(apply(out[["ground-truth"]]$var[!high,],2,mean))
  panel(out[[j]]$var[!high,k] / out[["ground-truth"]]$var[!high,k]
      , main = j
      , type = "experiments"
      , lty=1,
      , ylim = c(0,5) 
)
  abline(h=0, lty=2)
}
```

## variance by genes

```{r var-ratio-genes, fig.width=7.1, fig.height=7,fig.cap=c("a","b")}
par(mfrow=c(4, 3),mar=c(4,4,2,2))
for (j in names(out)){
  k <- order(apply(out[["ground-truth"]]$var[!high,],2,mean))
  panel(out[[j]]$var[!high,k] / out[["ground-truth"]]$var[!high,k]
      , main = j
      , type = "genes"
      , lty=1,
      , ylim = c(0,15) 
      )
  abline(h=1, lty=2)
}
```

```{r var-ratio-genes2, fig.width=7.1, fig.height=7,fig.cap=c("a","b")}
par(mfrow=c(4,3),mar=c(2,4,2,2))
for (j in names(out)[-1]){
  mean.var.by_gene <-apply(out[["ground-truth"]]$var,1,mean)
  k <- order(high + mean.var.by_gene)
  panel(out[[j]]$var[k,] / out[["ground-truth"]]$var[k,]
      , main = j
      , type = "genes"
      , lty=1, prob = c(0.25, 0.50, 0.75)
      , ylim = c(0,25) 
      , xaxt = "n"
      )
  abline(h=1, lty=2)
  abline(v=488)
  mtext(c("gene\n(low bead)","gene\n(high bead)"), side=1,line=1,at=c(244,488+244),cex=.5)
}
```


## Compute correlation at the aggregate level 

```{r cor, fig.width=7, fig.height=7}
comp.cor <- function(x, y) {
  rho <- cor(t(x),t(y), method="spearman")
  mean(diag(rho))
}
mean.cor <- sapply(out, function(x) comp.cor(x$mean, y=out$`ground-truth`$mean))
# var.mean <- sapply(out, function(x) mean(x$var))
var.mean <- sapply(out, function(x) mean(x$var/out$`ground-truth`$var))
high <- ds@rdesc$high_prop == 1
var.mean.hi <- sapply(out, function(x) mean(x$var[high,]/out$`ground-truth`$var[high,]))
var.mean.lo <- sapply(out, function(x) mean(x$var[!high,]/out$`ground-truth`$var[!high,]))

# mean
panel <- function(x, ...) {
  i <- order(x)
  i.col <- factor(names(x)=="benchmark")[i]
  b <- barplot(x[i], horiz=F, las=2, col=c(gray(.75),"red")[i.col], ylim=c(0,15),...)
  text(x=b, y=x[i], round(x[i],2), pos=3, xpd=T)
}
par(mfrow=c(1,3), mar=c(7,3,3,1))
# panel(mean.cor, main = "Avg. rank correlation (replicates)")
panel(var.mean, main = "Median var ratio")
panel(var.mean.hi, main = "Mean var ratio high")
panel(var.mean.lo, main = "Mean var ratio lo")
```
